---
title: 节流和防抖
date: 2021-03-25 18:59:05
permalink: /pages/af9354/
categories:
  - js
  - JS相关内容
tags:
  - JS
---
# 节流和防抖 

## 为什么需要节流和防抖

在日常我们写代码的过程中，会出现很多的高频事件，比如浏览器页面的滚动事件 `onscroll`，浏览器窗口的缩放事件 `resize`，这些事件在我们触发时，会执行回调函数很多次，有可能 1s执行了好几十次，但是对于功能需求而言，我们可能只需要最后一次的执行结果，或者希望它的执行有一个间隔时间，比如 1s 执行一次，那么这个时候就需要用到 **节流和防抖** 来对回调函数的执行加一个限制

## 什么是节流和防抖，它的作用是什么
::: tip 节流（throttle）
节流就是保证一段时间内，核心代码只会执行一次。
:::
简单的节流函数
```js
function throttle (func, wait) {
  let last = 0
  return function () {
    const now = + new Date
    if (now - last > wait) {
      func.apply(this, arguments)
      last = now
    }
  }
}
```

::: tip 防抖（debounce）
在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时
:::
简单的防抖函数
```js
function debounce(func, wait) {
  let timer
  return function () {
    clearTimeout(timer)
    timer = setTimeout(() => {
      func.apply(this, arguments)
    }, wait)
  }
}
```

简单的 节流和防抖 就这样就可以实现了，接下来我们来看看比较出名的两个库，看看他们对于 节流和防抖 是怎么处理的

## underscore.js
### throttle

首先在定义函数时，和简易版的比起来，多了 `options` 配置，可以做一些额外的操作，比如 `trailing` 表示是否在在延时结束后调用 `func`

```js
function throttle(func, wait, options) {}
```

定义了返回 函数 `throttled` 以及使用到的变量，实现简单的节流

```js
function throttle(func, wait, options) {
  let args, context, last = 0
  const throttled = () => {
    args = arguments
    context = this
    const now = +new Date
    const remaning = wait - (now - last)
    if (remaning <= 0 || remaning > wait) { // 第一次会触发 或者 wait 时间到了会触发
      func.apply(context, args)
      last = now
    }
  }
  return throttled
}
```

这个时候 `options` 还是没有用到， 接下来要处理 `options` 的内容
```js
function throttle(func, wait, options = {}) {
  // trailing 最后一次默认是触发的
  let args, context, last = 0, timer // 添加一个定时器 用来计算最后一次
  const later = () => { // 最后一次执行的方法
    timer = null
    func.apply(context, args)
    last = +new Date
  }
  const throttled = () => {
    args = arguments
    context = this
    const now = +new Date
    const remaning = wait - (now - last)
    if (remaning <= 0 || remaning > wait) {
      if (timer) {
        clearTimeout(timer)
        timer = null
      }
      func.apply(context, args)
      last = now
      return
    } else if (!timer && options.trailing !== false) {
      timer = setTimeout(later, remaning) // 定时器为最后剩余的时间，也就是 wait 减去 已经度过的时间
    }
  }
  return throttled
}
```

处理 `leading` ， 开始是否执行
```js
function throttle(func, wait, options = {}) {
  // trailing 最后一次默认是触发的
  let args, context, last = 0, timer
  const later = () => {
    timer = null
    last = options.leading === false ? 0 : +new Date
    func.apply(context, args)
    last = +new Date
  }
  const throttled = () => {
    args = arguments
    context = this
    const now = +new Date
    if (!last && options.leading === false) last = now // 如果 leading 为 false ， 那么此时将 last 置为 now ，那么第一次就不会触发 事件执行
    const remaning = wait - (now - last)
    if (remaning <= 0 || remaning > wait) {
      if (timer) {
        clearTimeout(timer)
        timer = null
      }
      func.apply(context, args)
      last = now
      return
    } else if (!timer && options.trailing !== false) {
      timer = setTimeout(later, remaning)
    }
  }
  return throttled
}
```
